<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Photo Kiosk (final YouTube fix)</title>
<style>
html,body{margin:0;height:100%;background:black;overflow:hidden;}
#slideshow{position:relative;width:100%;height:100%;}
.slide{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:black;opacity:0;transition:opacity .7s ease-in-out;}
.mux-grid{display:grid;width:100%;height:100%;background:black;gap:2px;}
.mux-cell{position:relative;overflow:hidden;background:black;}
.mux-inner{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;will-change:transform;}
.mux-inner img{max-width:100%;max-height:100%;object-fit:contain;display:block;}
iframe{position:absolute;inset:0;width:100%;height:100%;border:none;z-index:1;}
</style>
</head>
<body>
<div id="slideshow"></div>
<script>
async function loadShow(){const r=await fetch("/api/slideshow");const j=await r.json();return j.slides||[];}
function parseAlign(a){if(!a)return{x:"center",y:"center"};const p=a.trim().split(/\s+/);return{x:p[0]||"center",y:p[1]||"center"};}
function applyEffect(img,effect,dur){const d=(dur||5)*1000;if(effect==="kenburns-zoom-in")img.animate([{transform:"scale(1)"},{transform:"scale(1.15)"}],{duration:d,fill:"forwards",easing:"ease-in-out"});else if(effect==="kenburns-zoom-out")img.animate([{transform:"scale(1.15)"},{transform:"scale(1)"}],{duration:d,fill:"forwards",easing:"ease-in-out"});}

function playFrames(img, frames, fps, repeat, duration, effect, onDone) {
  if (!frames?.length) return onDone?.();

  const loops = repeat ?? 1;
  const totalFrames = frames.length * loops;

  // --- Compute total duration ---
  let totalDurationMs;
  if (duration && duration > 0) {
    totalDurationMs = duration * 1000; // user-specified total time
  } else if (fps && fps > 0) {
    totalDurationMs = (totalFrames / fps) * 1000;
  } else {
    totalDurationMs = totalFrames * 500; // default 0.5s per frame
  }

  const delay = totalDurationMs / totalFrames;
  let index = 0;

  const step = () => {
    img.src = frames[index % frames.length];
    index++;

    if (index < totalFrames) {
      // Schedule the next frame after the delay
      setTimeout(step, delay);
    } else {
      // Hold the final frame for a full delay before finishing
      setTimeout(() => onDone?.(), delay);
    }
  };

  step();
}


async function start(){
  const slides=await loadShow();
  const box=document.getElementById("slideshow");
  if(!slides.length){box.innerHTML="<h1 style='color:white'>No slides</h1>";return;}
  let idx=0;
  const a=document.createElement("div"),b=document.createElement("div");
  a.className=b.className="slide";box.append(a,b);

  async function renderSlide(target,slide,all,onDone){
    target.innerHTML="";
    const inMux=!!target.closest(".mux-grid");
    const type=(slide.type||"").toLowerCase();   // normalize safely
    console.log(`â–¶ renderSlide: ${slide.id||"(no id)"} type=${type} inMux=${inMux}`);

    // ---------- YOUTUBE ----------
    if(type==="youtube" && slide.video_id){
      console.log(`ðŸŽ¬ YouTube embed ${slide.video_id}`);
      const f=document.createElement("iframe");
      f.allow="autoplay; fullscreen";
      f.src=`https://www.youtube.com/embed/${slide.video_id}?autoplay=1&mute=1&controls=0&rel=0&modestbranding=1`;
      target.appendChild(f);
      if(onDone && slide.duration!=="infinite") setTimeout(onDone,(slide.duration||30)*1000);
      return;
    }

    // ---------- GOOGLE DRIVE ALBUM (MUX-safe) ----------
    if (type === "google-drive" && slide.images?.length) {
      console.log(`ðŸ–¼ï¸ Rendering Google Drive album (${slide.images.length} images, ${slide.duration || 10}s each)`);

      const img = document.createElement("img");
      target.appendChild(img);

      const frames = slide.images.map(i => i.url);
      let index = 0;
      let cancelled = false;

      // Cancel helper if parent clears this slide early
      const observer = new MutationObserver(() => {
        if (!document.body.contains(target)) {
          cancelled = true;
          observer.disconnect();
        }
      });
      observer.observe(document.body, { childList: true, subtree: true });

      // Preload images before showing first
      await Promise.all(
        frames.map(
          src =>
            new Promise(res => {
              const im = new Image();
              im.onload = res;
              im.onerror = res;
              im.src = src;
            })
        )
      );

      const showNext = () => {
        if (cancelled) return;
        img.src = frames[index % frames.length];
        index++;
        if (index < frames.length) {
          setTimeout(showNext, (slide.duration || 10) * 1000);
        } else {
          observer.disconnect();
          onDone?.(); // signal completion back up the chain
        }
      };

      showNext();
      return;
    }


    // ---------- HTML PAGE ----------
    if(type==="html" && slide.url){
      const f=document.createElement("iframe");
      f.src=slide.url;target.appendChild(f);
      if(onDone && slide.duration!=="infinite") setTimeout(onDone,(slide.duration||15)*1000);
      return;
    }

    // ---------- MUX ----------
    if(type==="mux"){const grid=document.createElement("div");grid.className="mux-grid";
      const[rows,cols]=slide.layout.split("x").map(Number);
      grid.style.gridTemplateRows=`repeat(${rows},1fr)`;grid.style.gridTemplateColumns=`repeat(${cols},1fr)`;target.appendChild(grid);
      slide.panels.forEach((panel,pi)=>{const cell=document.createElement("div");cell.className="mux-cell";const inner=document.createElement("div");inner.className="mux-inner";cell.appendChild(inner);grid.appendChild(cell);
        const{x,y}=parseAlign(panel.align);inner.dataset.scale=panel.scale||1;
        const pos=()=>{const r=cell.getBoundingClientRect();inner.style.justifyContent=(x==="left"?"flex-start":x==="right"?"flex-end":"center");inner.style.alignItems=(y==="top"?"flex-start":y==="bottom"?"flex-end":"center");let tx=0,ty=0;if(x.endsWith("%"))tx=((parseFloat(x)-50)/100)*r.width;if(y.endsWith("%"))ty=((parseFloat(y)-50)/100)*r.height;inner.style.transform=`translate(${tx}px,${ty}px) scale(${inner.dataset.scale})`;};
        pos();new ResizeObserver(pos).observe(cell);
        const deck=(panel.slides||[]).map(id=>all.find(s=>s.id===id)).filter(Boolean);
        if(!deck.length)return;
        
        (async()=>{await new Promise(r=>setTimeout(r,pi*250));while(true){for(const s of deck){inner.innerHTML="";await new Promise(done=>renderSlide(inner,{...s,suppressTitle:true},all,done));}}})();});
      return;
    }

    // ---------- MULTI-FRAME ----------
if (slide.file?.includes("*") || (slide.frames && slide.frames.length)) {
  const img = document.createElement("img");
  target.appendChild(img);

  let frames = slide.frames || [];
  if (!frames.length && slide.file) {
    const pat = slide.file.replace(/^\/?/, "");
    const r = await fetch(`/api/frames?pattern=${encodeURIComponent(pat)}`);
    const j = await r.json();
    frames = j.frames || [];
  }
  if (!frames.length) return onDone?.();

  // Preload all frames before playback
  await Promise.all(
    frames.map(
      src =>
        new Promise(res => {
          const im = new Image();
          im.onload = res;
          im.onerror = res;
          im.src = src;
        })
    )
  );

  // --- timing fix ---
  // Ensure duration always has a valid positive value.
  // If effect is "cut" and no fps defined, default to 0.5s per frame.
  let dur = Number(slide.duration) > 0 ? Number(slide.duration) : undefined;
  if (!dur && slide.effect === "cut" && !slide.fps) {
    dur = frames.length * 0.5; // half-second per frame
  }

  // Now play frames using computed duration
  playFrames(img, frames, slide.fps, slide.repeat, dur ?? slide.duration, slide.effect, onDone);
  return;
}


    // ---------- STILL IMAGE ----------
    if(slide.file && !slide.file.includes("*")){
      const dur=slide.duration&&slide.duration>0?slide.duration:5;
      const holder=document.createElement("div");
      Object.assign(holder.style,{width:"100%",height:"100%",background:"black",display:"flex",alignItems:"center",justifyContent:"center"});
      target.appendChild(holder);
      const img=document.createElement("img");
      Object.assign(img.style,{maxWidth:"100%",maxHeight:"100%",objectFit:"contain",willChange:"transform"});
      holder.appendChild(img);
      const base=slide.file.replace(/^.*[\\/]/,"").split(".")[0];
      let triedUpper=false;
      const tryLoad=src=>img.src=src;
      img.onload=()=>{applyEffect(img,slide.effect,dur);setTimeout(onDone,dur*1000);};
      img.onerror=()=>{if(!triedUpper){triedUpper=true;tryLoad(`/photos/${base}.JPG`);}else onDone?.();};
      tryLoad(`/photos/${base}.jpg`);
      return;
    }

    // ---------- PAUSE ----------
    const dur=slide.duration&&slide.duration>0?slide.duration:5;
    console.log(`pause-only ${slide.id} (${dur}s)`);target.style.background="black";
    setTimeout(onDone,dur*1000);
  }

  function showSlide(i){if(i<0)i=slides.length-1;if(i>=slides.length)i=0;idx=i;const next=slides[idx];const ns=idx%2?b:a,cs=idx%2?a:b;renderSlide(ns,next,slides,()=>showSlide(idx+1));ns.style.opacity=1;cs.style.opacity=0;}
  renderSlide(a,slides[0],slides,()=>showSlide(1));a.style.opacity=1;
}
start();
</script>
</body>
</html>
