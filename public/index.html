<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Photo Kiosk (collage in/out + pixel border)</title>
<style>
html,body{margin:0;height:100%;background:black;overflow:hidden;}
#slideshow{position:relative;width:100%;height:100%;}
.slide{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:black;
  opacity:0;
  transition:opacity .7s ease-in-out;
  pointer-events:none;
}
.slide.active{pointer-events:auto;}

.mux-grid{display:grid;width:100%;height:100%;background:black;gap:2px;}
.mux-cell{position:relative;overflow:hidden;background:black;}
.mux-inner{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;will-change:transform;}
.mux-inner img{max-width:100%;max-height:100%;object-fit:contain;display:block;}

iframe{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  border:none;
  z-index:1;
  pointer-events:auto;
  background:black;
}
</style>
</head>
<body>
<div id="slideshow"></div>

<script>
/* ------------------------------------------------------------
   Load slideshow from backend
------------------------------------------------------------ */
async function loadShow() {
  const params = new URLSearchParams(window.location.search);
  const slideshow = params.get("slideshow") || "";

  let url = "/api/slideshow";
  if (slideshow.trim() !== "") {
    url += `?slideshow=${encodeURIComponent(slideshow)}`;
  }

  const r = await fetch(url);
  const j = await r.json();
  return j.slides || [];
}

/* ------------------------------------------------------------
   Helpers
------------------------------------------------------------ */
function parseAlign(a){
  if(!a) return {x:"center",y:"center"};
  const p=a.trim().split(/\s+/);
  return {x:p[0]||"center",y:p[1]||"center"};
}

function applyEffect(img,effect,dur){
  const d=(dur||5)*1000;
  if(effect==="kenburns-zoom-in")
    img.animate([{transform:"scale(1)"},{transform:"scale(1.15)"}],
      {duration:d,fill:"forwards",easing:"ease-in-out"});
  else if(effect==="kenburns-zoom-out")
    img.animate([{transform:"scale(1.15)"},{transform:"scale(1)"}],
      {duration:d,fill:"forwards",easing:"ease-in-out"});
}

function playFrames(img,frames,fps,repeat,duration,effect,onDone){
  if(!frames?.length) return onDone?.();
  const loops=repeat??1;
  const total=frames.length*loops;
  const dur=(duration>0?duration*1000:(fps>0?(total/fps)*1000:total*500));
  const delay=dur/total;
  let i=0;
  const step=()=>{
    img.src=frames[i%frames.length];
    i++;
    if(i<total) setTimeout(step,delay);
    else        setTimeout(()=>onDone?.(),delay);
  };
  step();
}

/* ------------------------------------------------------------
   Collage Renderer (UPGRADED â€” supports cut/fade/dissolve + params)
------------------------------------------------------------ */
function renderCollage(target, slide, onDone) {
  const rect = target.getBoundingClientRect();
  if (rect.width < 5 || rect.height < 5) {
    return requestAnimationFrame(() => renderCollage(target, slide, onDone));
  }  
  const {
    images,
    duration = 90,
    fps = 1.0,
    imageMinSize = 0.25,
    imageMaxSize = 0.40,
    imageMaxPosition = 0.33,
    borderWidth = 4,
    borderColor = "white",
    background = "black",
    imageInEffect = "cut",      // cut | fade | dissolve
    imageOutEffect = "fade"     // fade (currently only supported out effect)
  } = slide;

  target.style.background = background;

  const W = target.clientWidth;
  const H = target.clientHeight;

  /* -----------------------------
     Helper: create image box
  ----------------------------- */
  function createImageBox(url) {
    const box = document.createElement("div");
    box.style.position = "absolute";
    box.style.boxSizing = "border-box";
    box.style.border = `${borderWidth}px solid ${borderColor}`;
    box.style.borderRadius = "2px";
    box.style.overflow = "hidden";
    box.style.opacity = 0;

    // Randomized size
    const scale = imageMinSize + Math.random() * (imageMaxSize - imageMinSize);
    const w = W * scale;
    const h = H * scale;

    // Position jitter
    const ox = (Math.random()*2 - 1) * imageMaxPosition * W;
    const oy = (Math.random()*2 - 1) * imageMaxPosition * H;

    box.style.width = `${w}px`;
    box.style.height = `${h}px`;
    box.style.left = `${(W - w)/2 + ox}px`;
    box.style.top  = `${(H - h)/2 + oy}px`;

    // Image element
    const img = document.createElement("img");
    img.src = url;
    img.style.width = "100%";
    img.style.height = "100%";
    img.style.objectFit = "cover";
    box.appendChild(img);

    target.appendChild(box);
    return box;
  }

  /* -----------------------------
     EFFECT HELPERS
  ----------------------------- */
  function doInEffect(box) {
    if (imageInEffect === "cut") {
      box.style.opacity = 1;
      return;
    }

    if (imageInEffect === "fade") {
      box.animate(
        [{opacity:0},{opacity:1}],
        {duration:700,fill:"forwards",easing:"ease-out"}
      );
      return;
    }

    if (imageInEffect === "dissolve") {
      box.animate(
        [
          {opacity:0, filter:"blur(8px)"},
          {opacity:1, filter:"blur(0px)"}
        ],
        {duration:900,fill:"forwards",easing:"ease-out"}
      );
      return;
    }

    // default fallback
    box.style.opacity = 1;
  }


  function doOutEffect(box) {
    if (imageOutEffect === "fade") {
      const anim = box.animate(
        [{opacity:1},{opacity:0}],
        {duration:700,fill:"forwards",easing:"ease-in"}
      );
      anim.onfinish = () => box.remove();
      return;
    }

    // fallback: remove instantly
    box.remove();
  }


  /* -----------------------------
     Collage Loop
  ----------------------------- */

  const msPerImage = 1000 / fps;
  const totalRun = duration * 1000;

  let idx = 0;
  let running = true;

  function showNext() {
    if (!running) return;

    const url = images[idx % images.length].url;
    idx++;

    const box = createImageBox(url);
    doInEffect(box);

    // Schedule removal after a display window (~5s)
    setTimeout(() => doOutEffect(box), 5000);

    // Schedule next image
    setTimeout(showNext, msPerImage);
  }

  // Stop entire collage after duration expires
  setTimeout(() => {
    running = false;
    onDone?.();
  }, totalRun);

  showNext();
}

/* ------------------------------------------------------------
   Main slideshow controller
------------------------------------------------------------ */
async function start(){
  const slides=await loadShow();
  const box=document.getElementById("slideshow");

  if(!slides.length){
    box.innerHTML="<h1 style='color:white'>No slides</h1>";
    return;
  }

  let idx=0;
  const a=document.createElement("div"),
        b=document.createElement("div");

  a.className=b.className="slide";
  box.append(a,b);

  /* ------------------------------------------------------------
     Render a single slide
  ------------------------------------------------------------ */
  async function renderSlide(target,slide,all,onDone){
    target.innerHTML="";
    const type=(slide.type||"").toLowerCase();

    console.log(`â–¶ renderSlide: ${slide.id||"(no id)"} type=${type}`);

    /* ---------- YOUTUBE ---------- */
    if (type === "youtube" && slide.video_id) {
      const f = document.createElement("iframe");
      f.allow = "autoplay; fullscreen";

      let src = `https://www.youtube.com/embed/${slide.video_id}?autoplay=1&mute=1&controls=0&rel=0&modestbranding=1`;

      // Add start time if provided and > 0
      if (slide.start && Number(slide.start) > 0) {
        src += `&start=${Number(slide.start)}`;
      }

      f.src = src;
      target.appendChild(f);

      if (onDone && slide.duration !== "infinite") {
        setTimeout(onDone, (slide.duration || 30) * 1000);
      }
      return;
    }

    /* ---------- MOVIE ---------- */
    if (type === "movie" && slide.file) {
      console.log("ðŸŽž Movie file:", slide.file);

      const vid = document.createElement("video");

      // âœ” Chrome autoplay rule: MUST be muted BEFORE assigning src
      vid.muted = true;
      vid.autoplay = true;
      vid.controls = false;
      vid.playsInline = true;

      // After autoplay & muted flags are set â†’ safe to assign src
      vid.src = slide.file;

      Object.assign(vid.style, {
        width: "100%",
        height: "100%",
        objectFit: "contain",
        background: "black"
      });

      target.appendChild(vid);

      vid.addEventListener("error", () =>
        console.error("VIDEO ERROR:", vid.error)
      );

      vid.addEventListener("loadedmetadata", () => {
        // START OFFSET (seconds)
        if (slide.start && Number(slide.start) > 0) {
          const startSeconds = Number(slide.start);
          console.log(`â© Seeking to ${startSeconds}s`);
          vid.currentTime = startSeconds;
        }


        const attemptPlay = () => {
          vid.play().catch(err => {
            console.error("â–¶ï¸ Playback failed:", err);

            // âœ” If Chrome still refuses (rare), keep muted
            if (err.name === "NotAllowedError") {
              vid.muted = true;
              vid.play().catch(e2 =>
                console.error("â–¶ï¸ Muted playback also failed:", e2)
              );
            }
          });
        };

        // Keep your slight delay
        setTimeout(attemptPlay, 50);
      });

      if (onDone && slide.duration !== "infinite") {
        vid.addEventListener("ended", () => onDone());
        setTimeout(onDone, (slide.duration || 30) * 1000);
      }

      return;
    }

    /* ---------- REMOTE STILL IMAGE ---------- */
    if(slide.file && /^https?:\/\//i.test(slide.file)){
      const dur = slide.duration>0?slide.duration:5;

      const holder=document.createElement("div");
      Object.assign(holder.style,{
        width:"100%",height:"100%",background:"black",
        display:"flex",alignItems:"center",justifyContent:"center"
      });
      target.appendChild(holder);

      const img=document.createElement("img");
      Object.assign(img.style,{
        maxWidth:"100%",maxHeight:"100%",objectFit:"contain"
      });
      holder.appendChild(img);

      img.src=slide.file;
      img.onload=()=>{
        applyEffect(img,slide.effect,dur);
        setTimeout(onDone,dur*1000);
      };
      img.onerror=()=>onDone?.();
      return;
    }

    /* ---------- WEB PAGE (IFRAME WRAPPER) ---------- */
    if (type === "webpage" && slide.url) {
      const dur = slide.duration > 0 ? slide.duration : 10;

      const frame = document.createElement("iframe");
      Object.assign(frame.style, {
        width: "100%",
        height: "100%",
        border: "none",
        background: "black"
      });

      frame.src = slide.url;
      target.appendChild(frame);

      // Auto-advance after duration
      setTimeout(() => {
        frame.remove();
        onDone?.();
      }, dur * 1000);

      return;
    }


    /* ---------- LOCAL STILL IMAGE (FIXED: preserves folder + extension) ---------- */
    if (
      slide.file &&
      !slide.file.includes("*") &&
      !slide.file.toLowerCase().endsWith(".mp4") &&
      !slide.file.toLowerCase().endsWith(".mkv") &&
      !slide.file.toLowerCase().endsWith(".webm") &&
      type !== "movie" &&
      type !== "webpage"          // <-- prevent stealing webpage slides
    ) {
      const dur = slide.duration > 0 ? slide.duration : 5;

      const holder = document.createElement("div");
      Object.assign(holder.style, {
        width: "100%", height: "100%", background: "black",
        display: "flex", alignItems: "center", justifyContent: "center",
      });
      target.appendChild(holder);

      const img = document.createElement("img");
      Object.assign(img.style, {
        maxWidth: "100%", maxHeight: "100%", objectFit: "contain"
      });
      holder.appendChild(img);

      // Full path including folder
      const original = slide.file;
      const ext = original.substring(original.lastIndexOf(".") + 1);
      const base = original.substring(0, original.lastIndexOf("."));

      const lower = `/media/photos/${base}.${ext.toLowerCase()}`;
      const upper = `/media/photos/${base}.${ext.toUpperCase()}`;

      let triedUpper = false;

      img.onload = () => {
        applyEffect(img, slide.effect, dur);
        setTimeout(onDone, dur * 1000);
      };

      img.onerror = () => {
        if (!triedUpper) {
          triedUpper = true;
          img.src = upper;   // try uppercase extension
        } else {
          console.warn("Failed to load local image:", slide.file);
          onDone?.();
        }
      };

      img.src = lower;   // FIRST attempt = actual lowercase file
      return;
    }

    /* ---------- GOOGLE / ONEDRIVE (non-collage) ---------- */
    if((type==="google-drive"||type==="one-drive") && slide.images?.length){
      const frames=slide.images.map(i=>i.url);

      const wrapper=document.createElement("div");
      Object.assign(wrapper.style,{position:"relative",width:"100%",height:"100%"});
      target.appendChild(wrapper);

      await Promise.all(frames.map(src=>new Promise(resolve=>{
        const im=new Image();
        im.onload=im.onerror=resolve;
        im.src=src;
      })));

      const imgA=document.createElement("img"),
            imgB=document.createElement("img");

      [imgA,imgB].forEach(img=>Object.assign(img.style,{
        position:"absolute",inset:0,width:"100%",height:"100%",
        objectFit:"contain",opacity:0,transition:"opacity 1s ease-in-out"
      }));

      wrapper.append(imgA,imgB);
      imgA.style.opacity=1;

      const dur=(slide.duration||10)*1000;
      let index=0;
      const showNext=()=>{
        const next=frames[index%frames.length];
        const active=index%2?imgA:imgB;
        const passive=index%2?imgB:imgA;
        active.src=next;
        active.style.opacity=1;
        passive.style.opacity=0;
        index++;
        setTimeout(showNext,dur);
      };
      showNext();

      setTimeout(onDone,frames.length*dur);
      return;
    }

    /* ---------- HTML ---------- */
    if(type==="html" && slide.url){
      const f=document.createElement("iframe");
      f.src=slide.url;
      f.allow="autoplay; fullscreen; clipboard-write; encrypted-media; picture-in-picture";
      f.allowFullscreen=true;
      target.appendChild(f);

      if(onDone && slide.duration!=="infinite")
        setTimeout(onDone,(slide.duration||15)*1000);
      return;
    }

    /* ---------- MUX (uses panel.resolvedSlides) ---------- */
    if (type === "mux") {
      const grid = document.createElement("div");
      grid.className = "mux-grid";

      const [rows, cols] = slide.layout.split("x").map(Number);
      grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
      grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

      target.appendChild(grid);

      let running = true;
      let finished = false;

      // Duration handling
      const isInfinite = String(slide.duration).toLowerCase() === "infinite";
      const durationMs = isInfinite ? null : (Number(slide.duration) || 15) * 1000;

      if (!isInfinite) {
        setTimeout(() => {
          running = false;
          if (!finished) {
            finished = true;
            onDone?.();
          }
        }, durationMs);
      }

      slide.panels.forEach((panel, pi) => {
        const cell = document.createElement("div");
        cell.className = "mux-cell";

        const inner = document.createElement("div");
        inner.className = "mux-inner";

        cell.appendChild(inner);
        grid.appendChild(cell);

        // Positioning logic
        const { x, y } = parseAlign(panel.align);
        inner.dataset.scale = panel.scale || 1;

        const applyPos = () => {
          inner.style.justifyContent =
            x === "left" ? "flex-start" :
            x === "right" ? "flex-end" :
            "center";

          inner.style.alignItems =
            y === "top" ? "flex-start" :
            y === "bottom" ? "flex-end" :
            "center";

          inner.style.transform = `scale(${inner.dataset.scale})`;
        };

        applyPos();
        new ResizeObserver(applyPos).observe(cell);

        // â­ NEW: Use resolvedSlides sent by backend
        const deck = panel.resolvedSlides || [];

        if (!deck.length) return;

        // Panel animation loop
        (async () => {
          await new Promise(r => setTimeout(r, pi * 250)); // stagger startup

          while (running) {
            for (const s of deck) {
              if (!running) break;

              inner.innerHTML = "";

              await new Promise(done => {
                renderSlide(
                  inner,
                  { ...s, suppressTitle: true },
                  all,  // still passed, but not used for MUX panels now

                  // Safety wrapper
                  () => {
                    if (!running) return;
                    done();
                  }
                );
              });
            }
          }
        })();
      });

      return;
    }

    /* ---------- MULTI-FRAME ---------- */
    if(type==="multi-frame" || slide.file?.includes("*") || (slide.frames && slide.frames.length)){
      const holder=document.createElement("div");
      Object.assign(holder.style,{
        width:"100%",height:"100%",background:"black",
        display:"flex",alignItems:"center",justifyContent:"center"
      });
      target.appendChild(holder);

      const img=document.createElement("img");
      Object.assign(img.style,{
        maxWidth:"100%",maxHeight:"100%",objectFit:"contain"
      });
      holder.appendChild(img);

      let frames=slide.frames||[];

      if(!frames.length && slide.file){
        const pat=slide.file.replace(/^\/?/,"");
        const r=await fetch(`/api/frames?pattern=${encodeURIComponent(pat)}`);
        const j=await r.json();
        frames=j.frames||[];
      }

      if(!frames.length) return onDone?.();

      await Promise.all(frames.map(src=>new Promise(resolve=>{
        const im=new Image();
        im.onload=im.onerror=resolve;
        im.src=src;
      })));

      playFrames(img,frames,slide.fps,slide.repeat,slide.duration,slide.effect,onDone);
      return;
    }

    /* ---------- PAUSE ---------- */
    const dur=slide.duration>0?slide.duration:5;
    target.style.background="black";
    setTimeout(onDone,dur*1000);
  }

  /* ------------------------------------------------------------
     Slide switching
------------------------------------------------------------ */
  function showSlide(i){
    if(i<0) i=slides.length-1;
    if(i>=slides.length) i=0;
    idx=i;

    const next=slides[idx];
    const ns=idx%2?b:a;
    const cs=idx%2?a:b;

    cs.innerHTML="";

    ns.classList.add("active");
    cs.classList.remove("active");

    renderSlide(ns,next,slides,()=>showSlide(idx+1));

    ns.style.opacity=1;
    cs.style.opacity=0;
  }

  renderSlide(a,slides[0],slides,()=>showSlide(1));
  a.style.opacity=1;
  a.classList.add("active");
}

start();
</script>
</body>
</html>
